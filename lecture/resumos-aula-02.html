<html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h3>Resumos de aula: PLN - 2018</h3><br> <i>Nota: Arquivo gerado por um programa.</i><br><p><table border=1> <tr> <td>Nome</td> <td>Resumo</td> </tr>

<tr>
<td bgcolor=#99e699>Gabriel Martins Trettel</td>
<td> O objetivo da aula 2 de PLN foi mostrar uma ferramenta para procurar fragmentos de texto específicos num texto maior. Tendo um texto de referência com muitas páginas, como podemos procurar por um termo, frase ou conjunto de palavras de forma automática e com flexibilidade para encontrar algumas variações definidas? Dentre as opções disponíveis, expressões regulares é uma boa escolha; com ela podemos fazer pesquisas bem complexas com poucos caracteres de comando. Para fazer uma pesquisa, é muito simples, basta escrever a palavra ou frase desejada, no buscador. Caso seja preciso, existem alguns modificadores que aumentam a flexibilidade da pesquisa, por procurarem várias combinações diferentes de uma só vez. O modificador de disjunção, por exemplo, - representado por ‘[]’- faz com que cada elemento no seu interior se combine com o resto da expressão na busca de forma individual. A pesquisa “[aA]bacate” é similar a extrair ambas as palavras “Abacate” e “abacate” escrevendo apenas um termo. O operador disjunção aceita outros parâmetros,, tais como, 0-9, a-z, A- Z, ou a combinação simultânea de todos os anteriores, a-zA-Z0-9. Também podemos usar o operador ‘^’ para negar algum caractere dentro da disjunção; a pesquisa “abacate[^ ]” retornaria todas as palavras “abacate” em que não possuem um espaço logo em seguida, pois a busca aceitaria qualquer caracter exceto o espaço. Saídas válidas para o exemplo anterior poderiam sem “abacate,”, “abacate.”, por exemplo. Caso queiramos identificar uma expressão que possui um conjunto de palavras anteriores bem definido podemos extrair essas palavras sem, necessariamente, saber cada caractere. Um exemplo simples é procurar numa lista, em que cada linha é uma matéria diferente, todas as matérias que começam com “Processamento” mas também incluir seu código e as outras palavras que também fazem parte do nome da matéria: “[A-Z0-9- ]+Processamento.*\b”. Neste exemplo o primeiro modificador “[A-Z0-9- ]+” começa com a disjunção que seleciona qualquer caractere alfanumérico somente de letras maiúsculas (já que sabemos que o código da disciplina não possui minúsculas), números, espaço em branco e o caracter de subtração. O sinal de ‘+’ após o colchetes indica que temos um ou mais caracteres dentro do intervalo da disjunção. Ou seja podemos ter somente uma letra ou quantas forem necessárias desde o início da linha até chegar na palavra “Processamento” que a extração incluirá todas elas. Depois temos a palavra “Processamento”, já que ela é o nosso termo de pesquisa principal, e logo em seguida, temos um elemento ‘.*’ que indica qualquer string de caracteres, e no final temos o ‘\b’, que quebra a extração na última palavra, caso tenha um espaço adicional. Existem inúmeras outras ferramentas dentro das expressões regulares que são extremamente úteis no cotidiano de um programador. Como aplicação dessas técnicas,  temos o ELIZA, um software do tipo chat criado na década de 60 que “conversa” com um humano. O programa tenta encontrar palavras chave para responder de acordo com o assunto, geralmente uma pergunta, fazendo um trabalho rudimentar de psicanalista. E conseguimos reproduzir a funcionalidade do ELIZA nos dias de hoje usando um banco de dados que assimila cada palavra chave com uma possível resposta para aquele termo. Esta pesquisa das palavras chave fica fácil usando as técnicas vistas anteriormente.</td>
</tr>

<tr>
<td bgcolor=#99e699>Lucas Zanferrari Caraca</td>
<td> Expressão regular (ou regex) é uma ferramenta computacional utilizada para normalização de textos, divisão de texto em tokens, radicalização e segmentação de frases. Uma regex consiste em uma cadeia de texto (string), estruturada em uma linguagem formal própria, que é utilizada para buscar trechos de texto que "combinam" com as regras definidas por ela. Uma disjusção de um caractere dentro da expressão regular é definida dentro de colchetes. Por exemplo, se necessário buscar por qualquer caractere numérico no texto, podemos usar a expressão [0123456789], mas existem formas de simplificação. Se a sequência de caracteres que deve ser compreendida pela busca for contígua na tabela ASCII, basta separarmos o primeiro caractere do último por traço. No exemplo anterior, teríamos [0-9]. O acento circunflexo é utilizado para negar a disjunção. Ou seja, a busca se torna por qualquer caractere que não sejam os definidos entre colchetes. Para buscar todos os caracteres não minúsculos, incluindo números e caracteres especiais, pode-se usar a expressão [^a-z]. O pipe é utilizado como operador OU lógico. Por exemplo, se for preciso buscar as palavras "eu" ou "voce", pode-se utilizar a expressão eu | voce. Outras opções de operadores são o ponto de interrogação (?), o asterisco (*), o sinal de adição (+) e o ponto final (.). Eles definem na busca, respectivamente, um caractere predecessor opcional, um caractere predecessor que ocorra zero ou mais vezes, um caractere predecessor que ocorra pelo menos uma vez e a ocorrência de qualquer caractere. O acento circunflexo, quando utilizado fora do contexto da disjunção de um caractere, serve para delimitar o início de uma linha, enquanto o cifrão ($) define o fim. Ambos são chamados de caracteres âncoras. Se fosse preciso buscar linhas compostas por apenas uma letra maiúsculas no texto, poderia-se utilizar a expressão ^[A-Z]$, por exemplo. Após a definição destes elementos de sintaxe das expressões regulares, exemplos foram apresentados e os dois tipos de erros possíveis foram definidos. São eles: falsos positivos (quando uma string é identificada pela regex no texto, mas não deveria) e falsos negativos (quando uma string não é identificada pela regex no texto, mas deveria). Minimizar estes erros aumentam a precisão e a cobertura da busca, respectivamente. O teste aplicado nesta aula consistia em criar expressões regulares que buscassem por padrões específicos, como todas as cadeias alfabéticas que fossem terminadas com a letra "m", ou linhas que fossem iniciadas por números inteiros e terminadas por uma palavra. O destaque foi a última questão pois envolvia o conceito de armazenamento na memória e referencia a um padrão encontrado dinamicamente pela regex. Isto é feito utilizando parênteses e a instrução \1. As expressões regulares são exemplos de Autômatos Finitos Determinísticos. Representá-las como tal pode ajudar a definir se ela está bem escrita. Por padrão, as os motores de expressões regulares utilizam estratégias gulosas em suas execuções. A aula foi concluída com a demonstração de um dos primeiros sistemas de Processamento de Linguagem Natural, chamado de Eliza. Ele consistia em um programa que buscava e imitava alguns padrões de texto inseridos pelo usuário para formular uma resposta simples.</td>
</tr>

<tr>
<td bgcolor=#99e699>Hiago Lucas Cardeal de Melo Silva</td>
<td> Devido à complexidade dos alfabetos, criou-se um método formal para retirar trechos de textos chamado expressões regulares (Ers ou Regex). ERs, portanto, são concatenações de caracteres em uma linguagem formal que tem como objetivo buscar e extrair padrões em um texto. Supondo que exista um texto sobre capivaras e nós queremos saber quantas vezes o termo capivara é citado. Se simplesmente procurarmos pelo termo "capivara" nós estaremos negligenciando a palavra "Capivara" com "C" maiúsculo. Em expressões regulares, ao em vez de procurar pelos dois termos, simplesmente buscamo por: \[cC]apivara\. Este método é uma expressão regular e [cC] é chamado disjunção. Através de expressões regulares ainda podemos procurar por outras variações da palavra capivara, como por exemplo "capivaras". Durante a aula, nos foi dado uma tabela com diversos comando utilizados em expressões regulares para usarmos como referência durante a aula. Algumas palavras possuem um grande número de flexões e, portanto, seu trabalho de busca pode ocasionar erros. Um erro possível é identificar cadeias de letras que não deviam ter sido identificadas, erro chamado de falso positivo. Ou ainda, deixar de identificar cadeias de letras que deveriam ter sido identificadas, o chamado falso negativo. É possível avaliar a qualidade de uma busca através de duas medidas: Precisão: verdadeiro positivo/(verdadeiro positivo + falso positivo). Aumentar a precisão significa minimizar os falsos positivos. Recall: verdadeiro positivo/(verdadeiro positivo + falso negativo). Aumentar o recall significa diminuir o número de falsos negativos aumentando a cobertura. Expressões regulares nada mais são que um tipo de máquina de estados finita, ou ainda, autômato finito determinístico. Toda expressão regular pode ser desenhada como um autômato, esta é uma forma de avaliar se a ER está bem construída. Após a exposição do tema, nos foi dirigido um teste com cinco perguntas para serem respondidas utilizando expressões regulares. Duas questões merecem destaque: 1) Selecionar todas as palavras terminadas em m: um erro comum foi utilizar a ER \ [a-z]*m \ que retorna também subpalavras como amor. O correto seria \ [a- z]*m\b \ 2) Selecionar cadeias de palavras com duas repetições) A resposta para esta questão consistia em uma técnica que ainda não havíamos aprendido. basicamente existe o operador () que é capaz de "memorizar" o termo escrito nele. Para capturar este termo novamente basta utilizar o comando \1. Portanto a resposta é: \b(\w+)\W+\1 No final da aula o professor nos mostrou um chatbox simples que foi um dos primeiros sistemas de PLN chamado Eliza. Ele foi programado para manter as conversas limitadas. Em resumo este programa procura padrões textuais na conversa e a resposta de Eliza seria apenas uma substituição dos padrões, criando a ilusão de entendimento. </td>
</tr>

<tr>
<td bgcolor=#99e699>Ana da Silva de Paula</td>
<td> Expressões regulares são sequencias de caracretes construídas segundo uma linguagem formal que permitem identificar padrões textuais. Na prática, elas servem para executar buscas em textos, e por essa razão elas usualmente consistem na primeira etapa do processamento de textos. Os padrões encontrados por elas são utilizados em algoritmos de classificação e de aprendizado de máquina. Uma expressão regular pode ser representada por um autômato finito determinístico (AFD), que é uma representação abstrata de uma máquina com estados e transições entre eles, que são acessadas á medida que instruções são lidas. ERs por padrão são algoritmos gulosos, ou seja, sempre procuram pela cadeia de caracteres mais longa que atende aos critérios especificados. As linguagens de ERs permitem o uso de identificadores para informar que essa estratégia não deve ser utilizada. Expressões regulares podem ser utilizadas para a construção de formas rudimentares de chatbots; ELIZA é um exemplo delas. ELIZA era um sistema que possibilitava a manutenção de uma conversa através da imitação do que o usuário diz. As ERs por si só permitem que encontremos palavras ou expressões mais utilizadas em um texto, permitindo que tenhamos umanoção de seu coniteúdo sem precisar le-lo. Durante a aula de processamento de linguagem natural na qual foram abordados esses tópicos, fomos apresentados à sintaxe das ERs, parcialmente indicada a seguir: Colchetes ([]) indicam disjunções de caracteres; "[0-9]" indica a busca por um único caractere numérico entre 1 e 9; Acentos circunflexos (^) no início de uma cadeia indicam a negação da busca indicada a seguir; "[^5-6]" indica que devem ser procuradas as cadeias que não possuem 5 ou 6; Barras verticais (|) executam a disjunção entre palavras; "tu|você" indica que devem ser buscadas as ocorrências de "tu"  ou de "você"; Interrocações (?) indicam que o caractere antecessor é opcional; "você?s" indica que tanto "você" quanto "vocês" serão encontrados; Ponto final (.) indica que qualquer caractere pode estar naquela posição; "nes.a" identificará "nessa", "nesta" e "nesca", por exemplo. Asterisco (*) indica que o caractere antecessor pode aparecer zero ou mais vezes; "soco*rro" identificará "socrro", "socorro" e "socoooooorro", por exemplo. Mais (+) indica que o caractere antecessor pode aparecer uma ou mais vezes; "soco+rro" identificará "socorro" e "socoooooorro", por exemplo, mas não "socrro"; Os caracteres âncora indicam o início (^) ou o final ($) de uma linha; "^UFABC" e "UFABC$" encontrarão a string "UFABC" no inicio ou fim de uma linha, respectivamente. Efetuamos uma avaliação sobre o uso de expressões regulares, na qual testamos os conhcecimentos adquiridos e vimos um exemplo de busca que não podia ser realizada com as ferramentas vistas.</td>
</tr>

<tr>
<td bgcolor=#99e699>Gustavo Tino Ferreira</td>
<td> Uma expressão regular (ou regexp) é uma cadeia de texto, escrito em uma linguagem formal (normalmente padrão em todas as linguagens) cuja finalidade é buscar cadeias de textos específicas em um texto. Pode ser usado para normalizar um texto (deixar tudo maiúsculo ou tirar acentos, por exemplo), reduzir palavras para a sua versão mais simples (“are” vira “be”) e dividir uma frase baseada na sua pontuação. Existem dois tipos de erros possíveis quando usamos uma expressão regular. Quando um falso positivo ocorre, uma cadeia de caracteres é selecionada quando não deveria. Já um falso negativo ocorre quando uma cadeia atinge os critérios de seleção, porém não é selecionada. Para minimizar falsos positivos, é necessário aumentar a precisão, ou seja, restringir mais a sua ER, mesmo que isso gere alguns falsos negativos, a chance de ocorrer um falso positivo é menor. Para minimizar falsos negativos, o contrário deve ser feito, aumentar a cobertura. O tipo de solução deve ser escolhido com base no problema. Existem duas métricas para avaliar uma ER. A medida Precision é dada pela divisão do número de cadeias selecionadas corretamente pelo número total de cadeias selecionadas, é uma taxa de acerto. Já a medida Recall é dada pela divisão entre número de cadeias selecionadas corretamente pelo total de cadeias corretas (incluindo os falsos negativos). Uma ER também pode ser expressada como um autômato finito determinista. Todas os caracteres especiais que desempenham uma função podem ser encontrados num arquivo no tidia. A primeira questão do teste pedia para selecionar todas as cadeias alfabéticas. Isso pode ser feiro com: “[a­-zA-­Z]+” onde ocorre uma ou mais ocorrências de uma letra maiúscula ou minúscula.  Na segunda questão era necessário Selecionar todas as cadeias alfabéticas (em minúscula) que terminam com a letra ‘m’, para isso: “[a­-z]*m\b”, note que a ausência do “\b” implica em pegar subcadeias que terminam com m, por exemplo “academ” seria selecionado de “academia”, mesmo não terminando a palavra. A terceira questão pedia para selecionar todas as cadeias que começam no início da linha com um número inteiro e que terminam no final da linha com uma palavra. A resposta é: ^\d+\b.*\b\w+$.  Na última questão foi introduzido o “\1”, que repete a cadeia especificada anteriormente, servindo como “memória”. \b(\w+)\W+\1 é capaz de identificar a ocorrência de palavras repetidas (menos menos), pois \b faz com que a palavra não seja subpalavra de uma outra palavra (word boundary), (\w+) é uma cadeia alfanumérica de qualquer tamanho, \W um espaço ou separação e \1 serve para indicar a segunda ocorrência da palavra especificada anteriormente.</td>
</tr>

<tr>
<td bgcolor=#99e699>Thais Larissa Batista de Andrade</td>
<td> A segunda aula da disciplina introduziu o conceito de expressões regulares. As ERs - Expressões Regulares, desenvolvidas pelo matemático Stephen Kleene -, são cadeias de caracteres alfanuméricos utilizadas para procurar padrões textuais. Podemos especificar o que será buscado em um texto através do uso desses operadores. A busca por palavras mais simples pode ser feita utilizando o operador /. Por exemplo, se quisermos encontrar a palavra "capivara" em um texto, podemos utilizar a seguinte expressão: /capivara/. É importante enfatizar que essa busca diferencia letras maiúsculas e minúsculas, portanto para que a palavra "capivara" seja encontrada podemos utilizar a seguinte expressão /[cC]apivara/. Sempre que colocarmos um ou mais caracteres entre colchetes, estaremos indicando uma disjunção, no exemplo será buscada a palavra com c maiúsculo ou minúsculo. Também podemos indicar uma faixa de caracteres entre os colchetes, por exemplo, a seguinte expressão [A-Z] indica que um caractere maiúsculo de A à Z deve ser buscado. Além disso, caso queiramos negar essas disjunções podemos utilizar o operador circunflexo "^" logo no início da expressão, assim [^Aa] significa nem 'A' ou 'a'. Além da disjunção apresentada, também podemos utilizar a barra vertical entre duas expressões, por exemplo, podemos buscar [mM]andioca | [mM]acaxeira, e os resultados serão: mandioca, Mandioca, macaxeira e Macaxeira. Além dessas expressões, outras foram apresentadas como os caracteres âncoras, que indicam o inicio "^" e o fim "$" de uma linha. A estratégia das ERs são denotadas como gulosas pois dado uma busca, ela irá parar somente quando chegar ao final da frase, sendo necessário modificá-la com através dos operadores, caso isso não seja parte do objetivo. Para aprofundar os conhecimentos desses operadores fizemos um teste em sala no qual deveríamos criar as expressões regulares para encontrar as frases e palavras propostas pelo professor. Afim de compreender melhor como as ERs funcionam, podemos analisar a chatterbot Eliza. Ela foi o primeiro software a realizar o processamento da linguagem natural para conversar com um humano e utiliza a busca por padrões textuais para responder o interlocutor. Apesar de parecer óbvio, precisamos ter cuidado com a escrita das expressões regulares afim de reduzir erros de falso positivo e falso negativo, para isso precisamos aumentar a cobertura e a precisão, respectivamente. Portanto o estudo das ERs, de sua escrita elegante e precisa é essencial.</td>
</tr>

<tr>
<td bgcolor=#99e699>Juliane Kristine de Lima</td>
<td> Aula sobre expressões regulares, incluindo suas funções e a forma de reconhecimento de determinados padrões de caracteres relacionados com a escrita de textos. Dentre outras funções, expressões regulares são utilizadas para extrair trechos a partir de um texto. Normalmente, são o primeiro passo para qualquer processamento de texto e permitem melhorias em tecnologias de aprendizado de máquina. A definição formal de expressões regulares refere-se a cadeias de texto especiais, para identificação de cadeias de texto, e elas também são denominadas Regex e Regexp. Para extração de trechos padrões em textos, é necessário regularizar a identificação de sinônimos e palavras que podem ser escritas de várias maneiras. Alguns dos símbolos utilizados para esse tipo de processamento serão descritos na sequência: - Colchetes (exemplo: [cC]) - especificam uma disjunção de caracteres, na busca. Dentre os caracteres dentro dos colchetes, qualquer um é aceito como opção válida. Permite a implementação de faixas de caracteres (exemplo: [0-9] - Circunflexo dentro dos colchetes (exemplo: [^a-z]) - negação dos caracteres. -  Barra vertical [exemplo: nunca|jamais) - símbolo de OU. - Interrogação - caractere predecessor opcional. - Asterisco - caractere predecessor zero ou mais vezes. - Mais (+) - caractere predecessor uma ou mais vezes. - Ponto - Qualquer caractere, exceto vazio. - Barra (\) - caracter sucessor não é especial. - Circunflexo fora dos colchetes - âncora de início de linha. - Cifrão fora dos colchetes - âncora de final de linha. Informativo sobre o uso do site regex101, que permite a testagem de expressões regulares, conforme esse modelo de processamento. Há várias maneiras de fazer a busca da expressão regular, sendo algumas mais precisas do que as outras. É muito comum a ocorrência de erros, que podem ser de dois tipos: falsos positivos (identificação de cadeias irregulares) e falsos negativos (não identificação de cadeias corretas, que incluem a expressão regular). Na busca de minimizar os erros, é necessário aumentar a precisão, no caso dos falsos positivos, e aumentar a cobertura, no caso dos falsos negativos. Foi realizado um pequeno teste (sem atribuição de nota) para demonstrar o uso do conteúdo aprendido sobre expressões regulares. Na avaliação, exigiu-se a combinação dos símbolos estudados em sala de aula. Além disso, um dos exercícios exigia símbolos ainda não estudados, para dar um direcionamento para a continuidade do estudo.</td>
</tr>

<tr>
<td bgcolor=#99e699>Lucas Theodoro Guimaraes de Almeida</td>
<td> Introdução Na aula foi explicado o conceito de expressões regulares, mostrando algumas opções de descrição de seleção de texto, uma demonstração de uma breve aplicação, algumas ferramentas para ajudar no aprendizado e um teste.   Conceitos  Expressões regulares ou ER é utilizada para a normalização de texto, divisão em tokens, radicalização e segmentação de uma frase, para isso ela utiliza cadeia de texto especiais em uma linguagem formal. Um exemplo para utilização é a representação da palavra “Theo” tanto maiúsculo( Theo ) como minúsculo ( theo ), no caso utilizamos [ Tt ]heo. Porém para representar e selecionar textos essa ferramenta tem mais alguns atributos que serão descritos abaixo. Faixas de caracteres “[-]” : Tem como finalidade representar vários caracteres em um único espaço, [a-z] representa “a”, “b”, “c”, … , “ z”, já [A- Z1-9] representa “A”, “B”, … , “Z”, “1” , “2”, …, “9”. Disjunções “[^]”: É o contrário do que foi representado, [^Dd] é tudo menos “D” e “d”. Ou “|”: Quando queremos mostrar que pode ser mais de uma expressão regular, ER | RE no seria selecionado tanto ER e RE. Caractere [?]: caractere antecessor opcional, Th?eo seleciona tanto “Theo” como “Teo”. Caractere [*]: caractere antecessor selecionado de 0 ou mais vezes, UF*ABC representa UABC, UFABC, UFFABC, UFFFABC, UFFFFABC, etc. Caractere [+]: Caractere antecessor selecionado de 1 ou mais vezes, UF+ABC representa, UFABC, UFFABC, UFFFABC, UFFFFABC, etc. Caractere [.]: Representa qualquer coisa do meio, UF.ABC, representa UFAABC, UF!ABC, UFGABC, UFIABC, etc. Caractere [^]: Representa que a palavra vem no início da linha. Caractere [$]: Representa que a palavra vem no final da linha. Precedência (): Serve para mostrar precedência e guardar memória. Memória /”número”: Representa a memória salva na precedência.  Ferramenta A ferramenta mostrada foi o sitehttps://regex101.com/, onde é possível colocar um texto e uma expressão regular, assim ele seleciona e mostra os trechos de texto de maneira equivalente a ER.  Aplicação Uma aplicação são os chats bots como o Eliza, onde essa tem como finalidade conversar com o usuário. Uma outra aplicação é em pesquisa científica, onde as pessoas mineram texto através de expressões regulares.  Teste O teste foi constituído de 6 exercícios onde queria treinar e avaliar nosso conhecimento sobre ER, onde os próprios alunos que atribuiam a sua própria nota. </td>
</tr>

<tr>
<td bgcolor=#99e699>Andre Oliveira Macedo</td>
<td> Expressões regulares: Também conhecidas como Regex ou regexp, as expressões regulares, cadeias de texto especiais,  podem ser utilizadas na segmentação frases, radicalização,divisão de tokens e normalização de texto. Um exemplo dado é o efeito de disjunção dos [] na busca de expressões regulares, [1234567890] ou [0-9] para qualquer 1 dígito, [^A-Z] não um caractere maiúsculo, eu|voce para procurar por eu ou voce, porém, vale notar que os [] são utilizados apenas para um caractere. Outros exemplos de caracteres especiais são: '?' para caractere predecessor opcional ,'*' caractere predecessor 0 ou mais vezes ,'+' para caractere predecessor 1 ou mais vezes e '.' para qualquer 1 caractere que substitua. para representar o início de linha, o caractere '^' é utilizado na forma ^[A-Z], já o final de linha é representado por $, como padrão, '\' é utilizado como escape, indicando que o próximo caractere não é especial, exemplo: \^ ou \. . Pode-se utilizar o site recomendado regex101.com para testar o uso  das expressões regulares. Existem alguns atalhos para facilitar as buscas por expressões regulares, como no caso do \W  que é equivalente a [^a-zA-Z0-9], ou \d para qualquer dígito. EM PLN é importante minimizar os falsos positivos e falsos negativos, assim aumenta-se a precisão e a cobertura, pois obtém-se somente o que é desejado. Vale lembrar que uma expressão regular geralmente pode ser representado por um autômato finito determinístico, podendo-se construir um para verificar a validade da ER.  Teste de avaliação: Ao todo foram seis questões sobre expressões regulares, sendo que duas já possuíam respostas. Para testar as respostas, foi utilizado o site mencionado anteriormente. A primeira questão já estava respondida, a segunda era relativamente fácil, sendo necessário lembrar dos limites da palavra, já a terceira foi um pouco mais complexa, utilizando também os conceitos de começo de linha,  limite de palavra e fim de linha. A quarta também já estava respondida e ofereceu o conceito de agrupamento, a quinta desenvolveu o uso de agrupamento em conjunto com repetição  {}. A última questão abordou um conceito ainda não visto, que se refere a capacidade de memorização, pois para detectar duas palavras repetidas consecutivas, é necessário algum tipo de memória.Tal comando é '\1'.</td>
</tr>

<tr>
<td bgcolor=#99e699>Maria Clara Vilas Boas de Souza</td>
<td> Expressões regulares oferecem um método poderoso, flexível e eficiente de processamento de texto. A extensiva notação de correspondência de padrões de regex, como também são conhecidas, permite que você analise grandes quantidades de texto para encontrar padrões de caracteres específicos; para validar o texto e garantir que ele corresponda a um padrão predefinido (como um número de cpf); para extrair, editar, substituir ou excluir subcadeias de caracteres de texto. Também utilizadas para normalização de textos, que seria a sua padronização de acordo com normas e regras convenientes; tokenização, divisão das palavras separadas por espaços; radicalização, encontrar a ‘raiz’ das palavras; segmentação de frases, divisão em frases usando a pontuação. Para fazer uso de regex é necessário entender como sua linguagem funciona, para formar as expressões responsáveis pela busca dos padrões em textos são usados caracteres que representam funções específicas, como por exemplo os colchetes, que representação disjunção entre caracteres, ou a barra vertical (pipe) que representa a disjunção de caracteres, palavras ou outras expressões. Há também símbolos âncoras, coringas e outros que assumem o papel de expressões muito usadas a fim de facilitar a leitura do código. Um cuidado a ser tomado são com os erros, que entre os frequentes estão: falso positivo: Identificar resultados que não deveriam ser identificados; falso negativo: não encontrar trechos que deveriam ser identificados. Em PLN, e qualquer outro problema de reconhecimento de padrões, devemos lidar com esses 2 tipos de erros. Minimizar os Falsos Positivos: Aumentando a precisão. Minimizar os Falsos Negativos: Aumentando a cobertura. Na avaliação realizada em sala um problema chamou a atenção: “selecionar todas as cadeias com duas palavras repetidas consecutivas”, será possível  uma expressão regular ter memória? que no caso seria necessária para “lembrar” a cadeia encontrada para comparar com a seguinte. A solução compartilhada pelo professor foi a do uso combinado dos parênteses com \1 que indica a expressão contida num parênteses, referenciando o mesmo pela ordem em que aparece na expressão da esquerda para a direita.   </td>
</tr>

<tr>
<td bgcolor=#99e699>Lucas Alves Rangel</td>
<td>  Uma expressão regular é uma sequencia de caracteres que define um padrão de busca em texto e também pode ser vista como uma forma algébrica que descreve um conjunto de strings, é comumente usada em diversas tarefas de processamento de texto e busca de informação. Dado um padrão e um corpus de texto, uma busca de expressão regular vai buscar em todo corpus e retornar todas as linhas, documentos, etc  quais  possuam ocorrências que corresponda ao padrão dado ou simplesmente retornar o padrão encontrado. Colchetes são usados para descrever uma disjunção de caracteres a ser combinado. \[Dd]igito combina com "digito" e "Digito" Contadores, descrevem quantas vezes o padrão ou caractere precedente deve ocorrer. "\*"   zero ou mais vezes. "+" uma ou mais vezes. "?"  0 ou 1 vezes. "{n}" exatamente n vezes. "{n,m}" entre n e m vezes. "{n,}" n ou mais vezes. Ancoras: Ancoras são operadores que acorram uma expressão regular em uma precisa localização no texto. “^”  combina com uma expressão regular apenas se ela ocorre no começo de uma linha. “$” combina com uma expressão regular apenas se ela ocorre no final de uma linha. Operador de disjunção "|": "|" é o operador que descreve a disjunção entre duas expressões regulares. "\[a]{2}|ok" combina tanto com  "aa" como com "ok" Hierarquia de precedência de operadores: Parêntesis                   () Contadores                   + \* ? {} Sequencias e ancoras         cenoura   $ok    ^linha Operador de Disjunção        | Padrões podem ser ambíguos de diversas formais, por exemplo, o padrão "[a-zA-Z]" contra o texto “bolo de cenoura” combina tanto com “b” como com “bo”, “bol”, “bolo”, por padrão o os motores de expressões regulares combinam com a maior sequencia possível. Memória: É possível fazer referencia a padrões encontrados durante a busca, essa funcionalidade é chamada de memória e é considerada uma extensão das expressões regulares e pode não estar presente em todos os motores, para usar é necessário colocar parênteses em uma expressão e referenciar a n-ésima expressão que tenha parênteses por “\n”, exemplo: “(\d)a\1” combina com  “2a2” e “3a3” mas não com “1a2”  </td>
</tr>

<tr>
<td bgcolor=#99e699>Richard Anemam da Costa</td>
<td> Expressões Regulares 1. O que são Expressões Regulares (Regex ou Regexp) Expressão Regular é uma representação, ou seja, um conjunto de símbolos, que fornecem uma maneira de identificar e extrair padrões em um texto. Cada símbolo retrata algum tipo de informação. 2. Representações de Expressões Regulares * Os [ ] colchetes reconhecem qualquer caractere listadado dentro deles * [...-...] reconhece cada caractere listado no alcance * [^...] reconhece cada caracter não listado * [^...-...] reconhece cada caracter não listado no alcance * (...) agrupamento por precedência * * zero ou mais do antencessor * + um ou mais do antecessor * ? exatamente um ou zero do antecessor * \d qualquer digito de 0 à 9 * \w qualquer digito alfanumerico/underline * \s espaços em branco (espaço, tab) * ...|... reconhece qualquer um dos vizinhos, por exemplo (...) ou (...) * Veja mais sobre os simbolos que representam as expressões regulares aqui: https://tidia4.ufabc.edu.br/access/content/group/ff5ded65-3d10-4c36- af0e-33f9a65fdae8/regular-expression-syntax.pdf 3. Dois tipos de erros Durante a busca por padrões é possível encontrar dois erros possíveis. São eles: 1. Falso Positivo: identificar padrões que não deveriam ser identificados. Para lidar com esses erros podemos aumentar a precisão. 2. Falso Negativo: não identificar padrões que deveriam ser identificados. Para lidar com esses erros podemos aumentar a cobertura. 4. Entendendo as Expressões Regulares e suas utilidades As expressões regulares são o primeiro o passo para um processamento de um texto e podem ser descritas como uma máquina de estado finita (MEF). As espressões regulares são utilizadas por: * editores de texto * linguagens de programação (extrair texto baseado em padões) * validação (validar um e-mail, por exemplo) * chatbots (encontra padrões no texto e define uma resposta beaseada nesses modelos) * Aprendizado de Máquina * Etc. 5. Bibliografia http://professor.ufabc.edu.br/~jesus.mena/courses/pln-1q-2018/PLN-aula02.pdf https://tidia4.ufabc.edu.br/access/content/group/ff5ded65-3d10-4c36-af0e- 33f9a65fdae8/regular-expression-syntax.pdf https://tableless.com.br/o-basico-sobre-expressoes-regulares/ https://pt.wikipedia.org/wiki/Express%C3%A3o_regular#Uso </td>
</tr>

<tr>
<td bgcolor=#99e699>Paulo Ricardo Cunha da Silva</td>
<td> O conceito de Expressão Regular visto em aula é como uma String que é usada, para descrever um conjunto das mesmas utilizando-se de certas regras sintáticas. Suas aplicações são principalmente no desenvolvimento de Logicial e pode ser implementada em diversas linguagens de programação, um exemplo é a funcionalidade Localizar e Substituir que muitos editores de texto já comportam nativamente. As expressões regulares podem ser usadas como critérios de filtro na busca de texto, combinando o texto com o padrão de expressão regular.  Esse processo também é chamado de correspondência de padrões .  Por exemplo, é possível encontrar todas as palavras em uma lista de palavras que começam com S e terminam em D , sem ter que especificar explicitamente as letras ou o número deles.O termo expressão regular é essencialmente baseado no matemático Stephen Kleene .  Ele usou um nome quase idêntico, que ele chamou de quantidades regulares. As bases teóricas podem ser vistas em Linguagens formais e autômato onde podemos nos utilizar e sintaxe e semântica. Como pode ser implementada em diversas linguagens, há muitos exemplos onde o recurso é utilizado como por exemplo no filtro grep em sistemas Linux ou até mesmo em um dos mais primitivos sistemas de AI com interação básica chamado Eliza. No contexto de PLN elas são muitos importantes pois podem desempenhar grande papel como por exemplo na Bioinformática.  Elas são usadas ??em bancos de dados de proteína para descrever motivos protéicos.  A expressão regular Wx(9,11)-[VFY]-[FYW]-x(6,7)- [GSTNE]-[GSTQCR]-[FYW]-RSAP por exemplo pode ser utilizada para descrever um domínio de proteína no banco PROSITE. O teste 2 aplicado na aula consistia em 6 questões das quais 2 estavam respondidas e era necessário implementar Expressões Regulares para filtrar determinadas semânticas pedidas nos enunciados, apesar de aparentemente não ser complexo, dependendo da experiência algo que pode ser feito de forma simples torna-se muito grande. Embora estivesse confiante não consegui acertar tudo mas, o aprendizado foi importante.</td>
</tr>

<tr>
<td bgcolor=#99e699>Marcos Seiti Suzuki</td>
<td> Expressões regulares (ER) são geralmente utilizadas em buscas textuais. Alguns sinônimos utilizados são regex e regexp. É uma técnica quase inteligente. Comumente usada para: normalização de texto, divisão em tokens, radicalização (e.g., lemmatization, stemming) e segmentação  de frases. Uma definição mais formal para ER: cadeias de caracteres especiais, em uma linguagem forma, para busca/extração de trechos em um texto. Algumas ER: 1 - Disjunção : cadeia de caracteres entre colchetes [ ] irá identificar o primeira ocorrência de qualquer caractere entre os colchetes. Semelhante ao operador "ou" da lógica booleana. Ex.: [Cc]apivara irá procurar por capivara ou Capivara. Para representar uma faixa de caracter utiliza-se o hífen (sempre representado em ordem crescente). Ex. [0-9] busca a primeira ocorrência que contenha qualquer digito entre 0 e 9. 2- Negação em disjunção. ^ Nega a disjunção, sendo válida para o primeiro caractere. Ex.: [^A-A] Ciência da computação. identificara o caractere i. 3 - Outra disjunção | outra forma de disjunção é o uso da barra vertical |. Ex.: eu|voce identificará "eu " ou "voce" 4 - Para uso em caracteres predecessores ? * + . ? caractere predecessor opcional * caractere predecessor: 0 ou mais vezes + caractere predecessor:1 ou mais vezes . caractere coringa 5 - Caracteres âncoras ^$ ^inicio de linha $ final de linha 6 - Caractere de escape \ indica que o caractere seguinte não és especial Os tipos de erros comuns no uso das ER. Falso positivo, identificar cadeias que não deveria ser identificado. Falso negativo, não identificar cadeias que deveriam ser identificadas. Formas de minimizar os Falsos Positivos: aumentando a precisão. Forma de minimizar os falsos negativos: aumentando a cobertura. Geralmente as ERs são o primeiro passo para qualquer técnica que envolva processamento de texto. ER pode ser representado por uma máquina de estados finitos. ELIZA foi um dos primeiros programas de PLN. Desenvolvido pelo MIT entre os anos de 1964 e 1966. Era uma espécie de chatbot bem limitado e trabalha realizando buscas textuais na interação do usuário com o computador.</td>
</tr>

<tr>
<td bgcolor=#99e699>Marcos Freitas Parra</td>
<td> Assim como autômatos finitos são usados ??para reconhecer padrões de strings, expressões regulares são usadas para gerar padrões de strings. Uma expressão regular é uma fórmula algébrica cujo valor é um padrão que consiste em um conjunto de strings, chamado de linguagem da expressão. Operadores de uma expressão regular podem ser caracteres do alfabeto sobre os quais a expressão regular é definida, variáveis ??cujos valores são qualquer padrão definido por uma expressão regular, epsilon que denota a string vazia sem caracteres, nulo que denota o conjunto vazio de Strings. Expressões regulares fornecem um idioma expressivo para descrever padrões. Eles são particularmente úteis porque, como os padrões de Strings simples, eles podem ser procurados de forma eficiente em uma String maior. Acontece que, para qualquer expressão regular, pode ser construído um autômato finito determinístico (DFA) que reconhece qualquer string que a expressão regular descreva no tempo linear no comprimento da String! Um DFA, também conhecido como uma máquina de estados finitos, é um grafo finito em que os vértices são os estados do autômato. As arestas do gráfico são rotuladas com caracteres e existe um estado de início distinto e alguns estados de aceitação. Em um autômato finito determinístico, há no máximo uma aresta de saída de qualquer dado nó marcado com um carácter particular. O autômato inicia no estado inicial e varre o texto da esquerda para a direita. Para cada caractere de entrada, segue um único vértice de saída do estado atual rotulado com esse caractere. Por padrão, um quantificador diz ao motor que combine todas as instâncias da sua expressão quanto possível. Esse comportamento é chamado guloso. Por exemplo, pegue o quantificador +. Permite que o motor combine uma ou mais expressões: \d+ pode, portanto, combinar um ou mais dígitos. Por padrão, os quantificadores são gulosos,  \d+ combina o máximo de dígitos possível.</td>
</tr>

<tr>
<td bgcolor=#99e699>Raphael Kiyoshi Fukushima</td>
<td> Expressões regulares podem ser usadas para identificar palavras específicas, caracteres e cadeias de strings, ou até validar e identificar padrões, tudo isso de uma forma flexível e com certa precisão, por causa da acentuação presente na língua portuguesa, textos analisados devem ser convertidos sem seus acentos, ou podem sofrer na identificação das letras com acentos, porque os textos são analisados usando a tabela ASCII (American Standard Code for Information Interchange) e nesta tabela originalmente não existiam vogais com acentos por quase não serem usados na língua inglesa (foram introduzidas posteriormente em uma tabela estendida), e, atalhos e partes de códigos normalmente usados nas expressões regulares não abrangem tais letras. Como todo sistema de reconhecimento de padrões criar expressões regulares está vulnerável a erros como falso positivos ou falso negativos, mas ambos podem ser corrigidos aumentando sua precisão (considerando apenas o que realmente importa do item) e sua cobertura (considerando quantos itens relevantes são detectados), respectivamente. Um exemplo de expressão regular para validação de e-mail (vulnerável a erros como no slide da aula): / [\w\.\+-]+ @ [\w\.-]+ \. [a-zA-Z]{2,4} / Teste de Avaliação em Aula 1. Apenas para exemplificar uma expressão regular [a-zA-Z]+ 2. Um pequeno teste de atenção aos limites de quando se procura por uma palavra com um padrão específico em seu final [a-Z]*m\b 3.Uma expressão regular um pouco mais "elaborada" e como o uso de atalhos podem diminuir a linha de código ^[0-9]+\b.*\b[a-zA-Z]+$ ^  \d   +\b.*\b    \w     +$ 4. exemplo de como se utiliza alternância( ... | ... ) e agrupamento ( ( ... ) ) (gato)|(cachorro) 5. Uma expressão regular com alternância e agrupamento e com quantificação usando ( {n} ) (gato\s){2}|(cachorro) 6. Uma "pegadinha" onde para ser resolvida exigia um pequeno detalhe, o uso de "memória" presente no agrupamento ( ( ... ) \1 ) \b(\w+)\W+ \1 Expressões regulares podem ser testadas no site regex101.com</td>
</tr>

<tr>
<td bgcolor=#99e699>Clarissa Simoyama David</td>
<td> Expressões regulares (ER) podem ser utilizadas para extrair trechos a partir de um texto, com aplicações como normalização de um texto, divisão de tokens e radicalização. Em outras palavras, ER são cadeias de texto especiais para a extração de trechos de texto. Um exemplo dado foi caso deseje procurar sobre o animal capivara, neste caso pode ser procurado como [cC]apivara, que significa que será procurado tanto capivara como Capivara. Há características de ER: disjunções, em que a cadeia de caracteres que esteja dentro de colchetes especifica uma disjunção de caracteres a ser buscada; negação de disjunções, que é caracterizada pelo símbolo acento circunflexo; disjunção com barra vertical, que pode ter o mesmo significado de busca "ou"; outras opções, como ? (caractere predecessor opcional), * (caractere predecessor 0 ou mais vezes), + (caractere predecessor 1 ou mais vezes, . (caractere em questão repsentado pelo ponto poderá ser qualquer um); caracteres âncoras, início de linha (^) e final de linha ($). Em PLN há dois tipos de erros que devem ser lidados, falso positivo, que identifica cadeias que não deveriam ser identificadas, e falso negativo, em que não identifica cadeias que deveriam ser identificadas. Para minimizar falsos positivos aumenta-se a precisão, e para minimizar falsos negativos aumenta-se a cobertura. As ER são utilizadas em classificadores, podendo ser descrito como um autômato finito determinístico. Para a verificação se uma ER está bem construída é descrito a instrução utilizando o autômato finito determinístico. Também são utilizadas estratégias gulosas. Como forma de anexar o conteúdo, fora dado um teste de avaliação em sala, com perguntas como selecionar todas as cadeias que terminam com a letra m e selecionar todas as cadeias alfabéticas que tenham as palavras 'gato gato' ou 'cachorro'. O exercício mais complexo deste teste fora o que pedia para que fosse selecionado todas as cadeias com duas palavras repetidas consecutivas.</td>
</tr>

<tr>
<td bgcolor=#99e699>Higor Carmanini Barbosa</td>
<td> Aula 2 - Expressões Regulares Expressões regulares são formas de expressar cadeias textuais alfanuméricas que podem ser criadas a partir de autômatos finitos determinísticos. São comumente utilizadas pra normaliza?ão de texto, divisão em tokens, radicaliza?ão e segmenta?ão de frases. Também são referenciadas por Regex ou Regexp. Diretivas: Colchetes ([]) -> Disjun?ão de caracteres para busca, também usado com hífens para determinar intervalos [cC]apivara, [0-9] Circunflexo em disjun?ões (^) -> Nega?ão em disjun?ões. [^A-Z], [^Ss] Barra vertical (|) -> Alternativa. [cC](apivara|arpincho), eu|voce Interroga?ão (?) -> Caractere predecessor opcional pa?ra Asterisco (*) -> Caractere predecessor 0 ou mais vezes (fecho de Klein) aa*h! Cruz de soma (+) -> Caractere predecessor 1 ou mais vezes o+h! Ponto (.) -> Qualquer caractere ca.a Circunflexo (^) -> Início de linha ^[A-Z] Cifra ($) -> Final de linha \.$ (\ indica caractere não especial) Dois tipos de erro: Falso positivo, onde se identificam cadeias que não deveriam ser identificadas Falso negativo, onde não se identificam cadeias que deveriam ser identificadas Minimizar falsos positivos: aumentar precisão Minimizar falsos negativos: aumentar cobertura Geralmente são o primeiro passo de qualquer processamento de texto. O resultado de ERs é utilizado em classificarores de técnicas de aprendizado de máquina. É possível verificar a qualidade da constru?ão de uma ER através da montagem do AFD correspondente à expressão regular. Existem, além dos relatados, alguns outros operadores que abreviam ERs comuns, como \w, que se refere a qualquer caractere alfanumérico e underline, comum para e-mails, por exemplo. Na busca das cadeias é utilizada estratégia gulosa, devido à natureza dos AFDs. Eliza, um chatterbot feito com ERs, simula uma conversa com o interlocutor. Hoje em dia, inúmeros BOTs existem para atendimento a clientes. ERs também são usadas para identificar pessoas importantes em artigos científicos.</td>
</tr>

<tr>
<td bgcolor=#99e699>Alexsandro Francisco Dos Santos</td>
<td> Expressões regulares são cadeias de textos especiais que podem ser processadas em meio a um texto. De forma a encontrar esses padrões. Muito utilizados em extração de textos. A expressões regulares contemplam diversos operadores que podem ser utilizados para criar um padrão especifico para a cadeia de texto que você bem preferir. entre elas estão disjunções, como operadores OU. Exemplo: [cC]apivara|[cC]arpincho: captura uma ou outra cadeia (a ou b com o operador I em "a|b"), com ou sem letra maiuscula. Ainda, temos caracteres que permitem reconhecer uma repetição de padrões, ou apenas um elemento daquela repetição. Como: ?: Caractere predecessor opcional *: Caractere predecessor: 0 ou mais vezes +: Caractere predecessor: 1 ou mais vezes .: Placeholder para qualquer caractere apenas uma vez Alem disso, temos a funcionalidade de ancorar, como ^(inicio da linha) e $ (final da linha)  Como muitos Regex podem ser complexos, podemos usar o Regex101 para entender como cada padrão esta sendo computado e testar realtime sem necessidade de codificar diretamente. Com o regex, (e extendendo para qualquer problema de reconhecimento), podemos analisar os resultados Falsos ou Verdadeiros e Positivos ou Negativos. Sendo assim devemos minimizar os Falsos Positivos (resultados que retornam da regex mas não são o que queremos procurar) e os Falsos Negativos (resultados que queriamos retornar mas não retornaram). Uma regex é entendida como um Automato finito deterministico. Basicamente uma maquina de estado com um numero finito de estados. plus da aula: como o regex se comporta como um automato finito deterministico, ele não salva seus estados anteriores, mas as principais implementações de regex implementam formas de armazenar o ultimo padrão capturado, dessa forma você pode referenciar palavras encontradas dentro de um regex, usando "\x" sendo x a posição do padrão numa especie de lista de padrões.  </td>
</tr>

<tr>
<td bgcolor=#99e699>Maira Zabuscha de Lima</td>
<td> Uma expressão regular (regex) serve para extrair trechos de texto, normalizar, dividir em tokens, radicalizar, segmentar frases. Uma regex é formada a partir de uma linguagem formal.  Alguns símbolos servem para formar regras e não são interpretados literalmente. Os colchetes '[' e ']' especificam uma disjunção (ou exclusivo), exemplo [aB] significa 'a' minúsculo ou 'B' maiúsculo. O acento circunflexo dentro dos colchetes especifica a negação, exemplo [^aB] significa qualquer caractere menos 'a' minúsculo ou 'B' maiúsculo. A barra vertical | também significa disjunção. O ponto de interrogação '?' significa que o caractere anterior (ou disjunção) pode aparecer zero ou uma vez, ou seja, é opcional. O asterisco '*' significa que o caractere anterior (ou disjunção) pode aparecer zero ou mais vezes, ou seja, pode ser repetido. O sinal de adição '+' é similar mas o caracter deve aparecer pelo menos uma vez. A quantidade exata de caracteres a ser identifica pode ser especificada entre chaves, exemplo: {n} para n ocorrências, {n,m} para quantidade entre n e m, {n,} para no mínimo n ocorrências. O ponto '.' significa qualquer caractere, ou seja, funciona como um coringa. O acento circunflexo fora dos colchetes significa que o caractere seguinte (ou disjunção) deve ser inicial na linha, e o cifrão '$' significa que o caractere anterior deve finalizar a linha. Para que esses caracteres especiais sejam interpretados normalmente devem ser precedidos por uma barra '\'.  Podem haver dois tipos de erros: a não identificação de cadeias corretas (falsos negativos) e a identificação de cadeias incorretas (falsos positivos). Esses erros são prevenidos aumentando-se a cobertura ou a precisão, respectivamente.  Uma regex é equivalente a uma máquina de estados finita ou a um autômato finito determinístico pois gera linguagens regulares. </td>
</tr>

<tr>
<td bgcolor=#99e699>Eduardo da Silva Cruz</td>
<td> Expressões Regulares  Primeiro passo para extrair texto ou procurar determinadas palavras ou frases em textos já coletados  Podem ser usadas para:  Normalizaçao de texto (e.g., padronizar o texto convenientemente) Divisão em tokens (e.g., divisão em palavras usando os espaços?) Radicalização (e.g., lemmatization, stemming) Segmentação de frases (e.g., divisão em frases usando a pontuação)  Outros nomes: Regex, Regexp   Utilização:  [cC]apivara  = capivara ou Capivara [1234567890] = apenas um digito numeral 0 ou 1 ou 2 ... [0-­9]  = Apenas 1 digito [a­-z]  = Um caractere em minúscula [A­Z]  = Um caractere em maiúscula [5­-8]  = 5 ou 6 ou 7 ou 8 ^  = A negação válida como primeiro caractere [^A-­Z]  =  Não um caractere em maiúscula [^Ss]  = Nem 'S' nem 's' [^a^]  = Nem ‘a‘ nem ‘^‘ [cC]apivara|[cC]arpincho = capivara Capivara carpincho Carpincho pa?ra  = para pra aa*h!  = ah! aah! aaah! aaaaah! o+h!  = Oh! Ooh! Oooh! ca.a  = casa caza caça [ab]*  = aaaaaaa ababababa aaaabbbbb baaaaaaaa bbbbbbbbbbbbb [0­9][0­9]*  = Um número de pelo menos um digito. a$  = Casa \.$  = Casa. ^A UFABC\.$  = Uma linha contendo exatamente A UFABC. \  = ‘\’ serve para indicar que o caractere sucessor não é especial.   Dois tipos de erros:  Falso positivo: Identificar cadeias que não deveriam ser identificadas (humanidade, idade, cadeira)  Falso negativo: Não identificar cadeias que deveriam ser identificadas (De)   Teste de avaliação  1 = [a­zA­Z]+ 2 = [a­z]*m\b 3 = ^[0­9]+\b.*\b[a­zA­Z]+$ 4 = (gato)|(cachorro) 5 = (gato\s){2}|(cachorro) 6 = \b(\w+)\W+\1  Expressões são bem parecidas com a representação de gramaticas de LFA, procurar mais contato com RE para entender melhor</td>
</tr>

<tr>
<td bgcolor=#99e699>Lucas Mazim de Sousa</td>
<td> A aula de hoje foi sobre expressões regulares. O professor iniciou falando um pouco sobre o livro, base que atualmente esta na segunda edicao e indo para a terceiro, e seus autores. Expressão regular é uma técnica utilizada para realizar busca e extração de trechos em um texto. Com ela conseguimos normalizar o texto; realizar divisao de tokens; reduzir palavras ao seu radical e segmentar frases. O resultado das expressões regulares podem ser utilizados como atributos de um classificador de aprendizado de máquina. Entre as operações possíveis, em aula vimos a disjunção que pode ser chamada com colchetes ou [ ] ou barra vertical |. Por exemplo, [ 0-9 ] procura palavras que contenham ao menos um dígito entre 0 e 9. [ a-zA-Z ] procura palavras que contenham um caractere maiusculo ou minusculo. Com o acento circunflexo realizamos a operação de negação ^. Analisamos tambem operações com ? * + . $ ^ (em um contexto que indica inicio da linha) e como elas interagem em conjunto. A expressão regular [0-9][0-9]* procura por palavras que contenham pelo menos um digito. A ordem de precedencia entre os operadores é: parenteses, contadores, ancoras para sequencias e por fim disjunções. O professor utilizou o site https://regex101.com/ para mostrar como as expressões regulares funcionavam na prática. Falamos sobre dois tipo de erro, os falsos positivos (identificar cadeias que nao deveriam ser identificadas) e falsos negativos (nao identificar cadeias que deverias ser identificadas). Aumentando a precisão diminuimos os falsos positivos e aumentando a cobertura minimizamos os falsos negativos. Toda expressão regular pode ser transcrita como um automato finito deterministico. Houve um teste de avaliação em aula, deveriamos escrever as expressoes regulares para os problemas apresentados.</td>
</tr>

<tr>
<td bgcolor=#99e699>Leandro Akira Tochiro</td>
<td> Na aula do dia 22/02, aprendemos Expressões Regulares, de forma teórica e depois prática. De início, fomos apresentados às motivações e a importância das Expressões Regulares, que são formas de fazer uma busca bem precisa em algum texto, extraindo trechos. E depois, seguimos para suas classificações: As disjunções são representadas entre colchetes, que dá como resultado apenas um caractere. Exemplo: [aA]ula: busca tanto "aula" quanto "Aula", ou com números: [3-7], que busca os algarismos de 3 a 7. Também vimos como negar uma disjunção: [^a-z], dá como resultado qualquer caractere que não seja do alfabeto minúsculo. Vimos também as funções dos caracteres ?, *, +, .. O ? é usado depois de um caractere que pode ser opcional no texto. exemplo: tex?to, dá como resultado tanto "texto" quanto teto. O caractere * indica que o caractere antecessor pode aparecer 0 ou mais vezes. Exemplo: pod*e, dá como busca "poe", "pode", podde", "poddde" etc. Semelhante ao *, quando usamos o caractere +, significa que o caractere antecessor pode aparecer 1 ou mais vezes. Por fim, o "." é usado para substituir qualquer caractere. Exemplo: ca.a dá como resultado "cama", "capa", "casa" etc. Caracteres âncoras ^ e $: São usados para fixar que o trecho buscado deve aparecer no começo e/ou no final de uma linha, respectivamente.  Em seguida, vimos em aula várias aplicações e exemplos das Expressões Regulares aprendidas. Sobre o teste dado em sala: consistia em 4 testes, onde precisávamos escrever as Expressões regulares que estavam sendo pedidas e exemplificadas.</td>
</tr>

<tr>
<td bgcolor=#ffd480>Jair Pereira Junior</td>
<td> Expressões regulares (RE) são cadeias de texto especiais, em uma linguagem formal, para busca/extração de trechos de texto. RE são usadas para normalização de texto, divisão em tokens, radicalização e segmentação de frases. Podem ser representadas por um autômato finito determinístico (DFA). São compostas por tokens, que podem ser consultados em <https://regex101.com>. Este website também pode ser utilizado para praticar RE. A bibliografia recomendada para este tópico é Speech and language processing dos autores Daniel Jurafsky & James H. Martin. O teste de avaliação foi composto por 6 questões para praticar o básico de RE. Observou-se que o padrão em RE é usar estratégias gulosas e que uma RE representa mais do que um DFA consegue, como exemplo, RE possui memória. Quando construindo uma RE, deve se tomar cuidado com alguns tipos erros de classificação. Falso positivos, quando identifica-se cadeias que não deveriam ser identificadas. Falso negativo, quando não identifica-se cadeias que deveriam ser identificadas. Um exemplo prático de RE é o chatbot Eliza, um dos primeiros sistemas NLP. Eliza procura imitar respostas dos usuários através de padrões textuais, mantendo uma conversa limitada e superficial. Atualmente existem chatbot mais sofisticados. </td>
</tr></table><br> <hr> Arquivo gerado por um programa.<br><p></body></html>